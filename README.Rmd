---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# tscv

<!-- badges: start -->
<!-- badges: end -->

The package tscv provides a collection of functions and tools for time series analysis and forecasting as well as time series cross-validation. This is mainly a selection of functions that I find useful for research in the area of time series forecasting.

## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("ahaeusser/tscv")
```
## Example

```{r packages, message=FALSE}
# Load relevant packages
library(tscv)
library(tidyverse)
library(tsibble)
library(fable)
library(feasts)
Sys.setlocale("LC_TIME", "C")
```

The dataset `elec_price` is a hourly 'tsibble' with day-ahead electricity spot prices from the ENTSO-E Transparency Platform. The dataset contains time series data from 2019-01-01 00:00:00 to 2019-12-31 23:00:00 for five bidding zones in europe. We can use the function `clean_data` to prepare the dataset for further usage. The function checks whether the input data are a valid tsibble or not (regular spaced in time and ordered). Furthermore, implicit missing values are turned into explicit missing values (existing missing values are left untouched). If the data are provided in wide format, they are gathered into long format. For convenience, the index variable is renamed to `date_time`, the key variable is renamed to  `variable` and the measurement variable is renamed to `value`.

```{r clean data}
data <- elec_price %>%
  clean_data()

data
 
sub_data <- data %>%
  filter(variable == "Day-ahead Price (DE)")

sub_data %>% plot_ts()
sub_data %>% plot_season()
sub_data %>% plot_corr()

```

To prepare the dataset for time series cross-validation, we can use the function `split_data`. This function splits the data into training and testing (i.e. partitioning into time slices) for time series cross-validation. The user can choose between `stretch` and `slide`. The first is an expanding window approach, while the latter is a fixed window approach. The user can define the window sizes for training and testing via `n_init` and `n_ahead`, as well as the step size for increments via `n_step`.

```{r split data}

mode <- "slide"
n_init <- 2400
n_step <- 24
n_ahead <- 24

data <- data %>%
  split_data(
    mode = mode,
    n_init = n_init,
    n_step = n_step,
    n_ahead = n_ahead)

data <- data %>% 
  filter(slice %in% c(1:5))
```



```{r train}
models <- data %>%
  filter(sample == "train") %>%
  model(
    sNaive = SNAIVE(value),
    STLF = decomposition_model(STL(value ~ trend(window = 7), robust = TRUE), NAIVE(season_adjust)))

fcsts <- models %>%
  forecast_model(n_ahead = n_ahead)
```



```{r bind}
data <- bind_data(
  data = data,
  fcsts = fcsts)

data
```



```{r plot_forecast}
variable <- c("Day-ahead Price (DE)", "Day-ahead Price (NO1)")
model <- c("sNaive", "STLF", "TSLM")
slice <- c(1, 2)

plot_forecast(
  data = data,
  variable = variable,
  model = model,
  slice = slice,
  title = "Day-ahead electricity spot price",
  subtitle = "Actual versus forecast",
  caption = "Data: ENTSO-E Transparency Platform",
  ylab = "[Euro/MWh]",
  include = 168)
```



```{r errors}
# Evaluation
errors <- data %>%
  create_errors()

errors

plot_error_dist(
  data = errors,
  variable = variable,
  model = model)
```



```{r metrics}
metrics <- errors %>%
  error_metrics()

metrics


plot_error_metrics(
  data = metrics,
  variable = variable,
  model = model,
  metric = c("MAE", "MAPE"))
```



